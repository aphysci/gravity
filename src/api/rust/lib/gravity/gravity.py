# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.


import abc, logging, time
from .GravityDataProduct import GravityDataProduct 



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _gravity
else:
    import _gravity

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SUCCESS = _gravity.SUCCESS
FAILURE = _gravity.FAILURE
NO_SERVICE_DIRECTORY = _gravity.NO_SERVICE_DIRECTORY
REQUEST_TIMEOUT = _gravity.REQUEST_TIMEOUT
DUPLICATE = _gravity.DUPLICATE
REGISTRATION_CONFLICT = _gravity.REGISTRATION_CONFLICT
NOT_REGISTERED = _gravity.NOT_REGISTERED
NO_SUCH_SERVICE = _gravity.NO_SUCH_SERVICE
LINK_ERROR = _gravity.LINK_ERROR
INTERRUPTED = _gravity.INTERRUPTED
NO_SERVICE_PROVIDER = _gravity.NO_SERVICE_PROVIDER
NO_PORTS_AVAILABLE = _gravity.NO_PORTS_AVAILABLE
INVALID_PARAMETER = _gravity.INVALID_PARAMETER
TCP = _gravity.TCP
INPROC = _gravity.INPROC
PGM = _gravity.PGM
EPGM = _gravity.EPGM
IPC = _gravity.IPC
class GravityNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _gravity.GravityNode_swiginit(self, _gravity.new_GravityNode(*args))
    __swig_destroy__ = _gravity.delete_GravityNode

    def init(self, *args):
        return _gravity.GravityNode_init(self, *args)

    def registerDataProduct(self, *args):
        return _gravity.GravityNode_registerDataProduct(self, *args)

    def unregisterDataProduct(self, dataProductID):
        return _gravity.GravityNode_unregisterDataProduct(self, dataProductID)

    def subscribe(self, *args):
        return _gravity.GravityNode_subscribe(self, *args)

    def unsubscribe(self, *args):
        return _gravity.GravityNode_unsubscribe(self, *args)

    def publish(self, *args):
        return _gravity.GravityNode_publish(self, *args)

    def requestBinary(self, *args):
        return _gravity.GravityNode_requestBinary(self, *args)

                # The above request methods will both be renamed as requestBinary.  This provides a request method in the Python API that wraps the requestBinary
                # call and converts the serialized GDP into a Python GDP in the case of the synchronous request.
    def request(self, *args):
        ret = self.requestBinary(*args)

    # We only need to convert the return value in the synchronous case, which means no GravityRequestor arg
        synchronous = True
        for arg in args:
            if isinstance(arg, GravityRequestor):
                synchronous = False
        if synchronous:
            if len(ret) == 0:
                ret = None
            else:
                ret = GravityDataProduct(data=ret)
        return ret


    def registerService(self, serviceID, transportType, server):
        return _gravity.GravityNode_registerService(self, serviceID, transportType, server)

    def unregisterService(self, serviceID):
        return _gravity.GravityNode_unregisterService(self, serviceID)

    def startHeartbeat(self, interval_in_microseconds):
        return _gravity.GravityNode_startHeartbeat(self, interval_in_microseconds)

    def stopHeartbeat(self):
        return _gravity.GravityNode_stopHeartbeat(self)

    def registerHeartbeatListener(self, *args):
        return _gravity.GravityNode_registerHeartbeatListener(self, *args)

    def unregisterHeartbeatListener(self, *args):
        return _gravity.GravityNode_unregisterHeartbeatListener(self, *args)

    def waitForExit(self):
        while True:
            time.sleep(10)                


    def getStringParam(self, *args):
        return _gravity.GravityNode_getStringParam(self, *args)

    def getIntParam(self, key, default_value=-1):
        return _gravity.GravityNode_getIntParam(self, key, default_value)

    def getFloatParam(self, key, default_value=0.0):
        return _gravity.GravityNode_getFloatParam(self, key, default_value)

    def getBoolParam(self, key, default_value=False):
        return _gravity.GravityNode_getBoolParam(self, key, default_value)

    def getComponentID(self):
        return _gravity.GravityNode_getComponentID(self)

    def getIP(self):
        return _gravity.GravityNode_getIP(self)

    def getDomain(self):
        return _gravity.GravityNode_getDomain(self)

    def getCodeString(self, code):
        return _gravity.GravityNode_getCodeString(self, code)

    def subscribersExist(self, dataProductID):
        return _gravity.GravityNode_subscribersExist(self, dataProductID)

# Register GravityNode in _gravity:
_gravity.GravityNode_swigregister(GravityNode)
class GravityHeartbeatListener(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def MissedHeartbeat(self, componentID, microsecond_to_last_heartbeat, interval_in_microseconds):
        return _gravity.GravityHeartbeatListener_MissedHeartbeat(self, componentID, microsecond_to_last_heartbeat, interval_in_microseconds)

    def ReceivedHeartbeat(self, componentID, interval_in_microseconds):
        return _gravity.GravityHeartbeatListener_ReceivedHeartbeat(self, componentID, interval_in_microseconds)
    __swig_destroy__ = _gravity.delete_GravityHeartbeatListener

    def __init__(self):

            # check for > 2 parents
        gravityParents = set(["GravitySubscriber", "GravityServiceProvider",
                              "GravityRequestor",  "GravityHeartbeatListener"])
        numExtended = len(gravityParents.intersection([c.__name__ for c in self.__class__.__bases__]))
        if numExtended > 2:
            raise ValueError("\n\nCurrently only extending 2 Gravity classes is supported, but extending {}: \n\t\t{}.\nSee https://github.com/aphysci/gravity/issues/190.\n\n".format(numExtended, self.__class__.__bases__))


        if self.__class__ == GravityHeartbeatListener:
            _self = None
        else:
            _self = self
        _gravity.GravityHeartbeatListener_swiginit(self, _gravity.new_GravityHeartbeatListener(_self, ))
    def __disown__(self):
        self.this.disown()
        _gravity.disown_GravityHeartbeatListener(self)
        return weakref.proxy(self)

# Register GravityHeartbeatListener in _gravity:
_gravity.GravityHeartbeatListener_swigregister(GravityHeartbeatListener)
GRAVITY_LOG_FATAL = _gravity.GRAVITY_LOG_FATAL
GRAVITY_LOG_CRITICAL = _gravity.GRAVITY_LOG_CRITICAL
GRAVITY_LOG_WARNING = _gravity.GRAVITY_LOG_WARNING
GRAVITY_LOG_MESSAGE = _gravity.GRAVITY_LOG_MESSAGE
GRAVITY_LOG_DEBUG = _gravity.GRAVITY_LOG_DEBUG
GRAVITY_LOG_TRACE = _gravity.GRAVITY_LOG_TRACE
class Logger(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Log(self, level, messagestr):
        return _gravity.Logger_Log(self, level, messagestr)
    __swig_destroy__ = _gravity.delete_Logger

# Register Logger in _gravity:
_gravity.Logger_swigregister(Logger)
class Log(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NONE = _gravity.Log_NONE
    FATAL = _gravity.Log_FATAL
    CRITICAL = _gravity.Log_CRITICAL
    WARNING = _gravity.Log_WARNING
    MESSAGE = _gravity.Log_MESSAGE
    DEBUG = _gravity.Log_DEBUG
    TRACE = _gravity.Log_TRACE

    @staticmethod
    def LogLevelToString(level):
        return _gravity.Log_LogLevelToString(level)

    @staticmethod
    def LogStringToLevel(string):
        return _gravity.Log_LogStringToLevel(string)

    @staticmethod
    def initAndAddFileLogger(log_dir, comp_id, local_log_level):
        return _gravity.Log_initAndAddFileLogger(log_dir, comp_id, local_log_level)

    @staticmethod
    def initAndAddConsoleLogger(comp_id, local_log_level):
        return _gravity.Log_initAndAddConsoleLogger(comp_id, local_log_level)

    @staticmethod
    def initAndAddLogger(logger, log_level):
        return _gravity.Log_initAndAddLogger(logger, log_level)

    @staticmethod
    def CloseLoggers():
        return _gravity.Log_CloseLoggers()

    @staticmethod
    def fatal(format):
        return _gravity.Log_fatal(format)

    @staticmethod
    def critical(format):
        return _gravity.Log_critical(format)

    @staticmethod
    def warning(format):
        return _gravity.Log_warning(format)

    @staticmethod
    def message(format):
        return _gravity.Log_message(format)

    @staticmethod
    def debug(format):
        return _gravity.Log_debug(format)

    @staticmethod
    def trace(format):
        return _gravity.Log_trace(format)

    def __init__(self):
        _gravity.Log_swiginit(self, _gravity.new_Log())
    __swig_destroy__ = _gravity.delete_Log

# Register Log in _gravity:
_gravity.Log_swigregister(Log)
SPD_LOG_TRACE = _gravity.SPD_LOG_TRACE
SPD_LOG_DEBUG = _gravity.SPD_LOG_DEBUG
SPD_LOG_INFO = _gravity.SPD_LOG_INFO
SPD_LOG_WARNING = _gravity.SPD_LOG_WARNING
SPD_LOG_ERROR = _gravity.SPD_LOG_ERROR
SPD_LOG_CRITICAL = _gravity.SPD_LOG_CRITICAL
SPD_LOG_OFF = _gravity.SPD_LOG_OFF
class SpdLog(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TRACE = _gravity.SpdLog_TRACE
    DEBUG = _gravity.SpdLog_DEBUG
    INFO = _gravity.SpdLog_INFO
    WARNING = _gravity.SpdLog_WARNING
    ERROR = _gravity.SpdLog_ERROR
    CRITICAL = _gravity.SpdLog_CRITICAL
    OFF = _gravity.SpdLog_OFF

    @staticmethod
    def critical(message):
        return _gravity.SpdLog_critical(message)

    @staticmethod
    def error(message):
        return _gravity.SpdLog_error(message)

    @staticmethod
    def warn(message):
        return _gravity.SpdLog_warn(message)

    @staticmethod
    def info(message):
        return _gravity.SpdLog_info(message)

    @staticmethod
    def debug(message):
        return _gravity.SpdLog_debug(message)

    @staticmethod
    def trace(message):
        return _gravity.SpdLog_trace(message)

    def __init__(self):
        _gravity.SpdLog_swiginit(self, _gravity.new_SpdLog())
    __swig_destroy__ = _gravity.delete_SpdLog

# Register SpdLog in _gravity:
_gravity.SpdLog_swigregister(SpdLog)
class GravitySubscriber(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gravity.delete_GravitySubscriber


            # DO NOT override or alter this method. It is here to convert between a list of serialized, binary Python strings 
            # representing GravityDataProduct's to a list of GravityDataProduct Python objects.
    def subscriptionFilledBinary(self, *args):
        gdpList = []
        for byteStr in args[0]:
            try:
                gdpList.append(GravityDataProduct(data=byteStr))
            except Exception as e:
                logging.exception("Error creating GDP from byte array")
        try:
            self.subscriptionFilled(gdpList)
        except Exception as e:
            logging.exception("Exception caught calling client subscriptionFilled")



    	    # The above subscriptionFilled will be renamed as subscriptionFilledBinary, and will be invoked from C++ when data is available.
    	    # Python GravitySubscriber child classes should only override this abstract method, which will be called with a list of
    	    # GravityDataProduct objects.
    @abc.abstractmethod
    def subscriptionFilled(self, dataProducts): pass


    def __init__(self):

            # check for > 2 parents
        gravityParents = set(["GravitySubscriber", "GravityServiceProvider",
                              "GravityRequestor",  "GravityHeartbeatListener"])
        numExtended = len(gravityParents.intersection([c.__name__ for c in self.__class__.__bases__]))
        if numExtended > 2:
            raise ValueError("\n\nCurrently only extending 2 Gravity classes is supported, but extending {}: \n\t\t{}.\nSee https://github.com/aphysci/gravity/issues/190.\n\n".format(numExtended, self.__class__.__bases__))


        if self.__class__ == GravitySubscriber:
            _self = None
        else:
            _self = self
        _gravity.GravitySubscriber_swiginit(self, _gravity.new_GravitySubscriber(_self, ))
    def __disown__(self):
        self.this.disown()
        _gravity.disown_GravitySubscriber(self)
        return weakref.proxy(self)

# Register GravitySubscriber in _gravity:
_gravity.GravitySubscriber_swigregister(GravitySubscriber)
class GravityRequestor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gravity.delete_GravityRequestor


            # DO NOT override or alter this method. It is here to convert between a serialized, binary Python string 
            # representing a GravityDataProduct to a GravityDataProduct Python object.
    def requestFilledBinary(self, *args):
        serviceID = args[0]
        requestID = args[1]
        try:
            response = GravityDataProduct(data=args[2])
            try:
                self.requestFilled(serviceID, requestID, response)
            except Exception as e:
                logging.exception("Exception caught calling client requestFilled")
        except Exception as e:
            logging.exception("Error creating GDP from byte array")



    	    # The above requestFilled will be renamed as requestFilledBinary, and will be invoked from C++ when a response is available.
    	    # Python GravityRequestor child classes should only override this abstract method.
    @abc.abstractmethod
    def requestFilled(self, serviceID, requestID, response): pass


    def requestTimeout(self, serviceID, requestID):
        return _gravity.GravityRequestor_requestTimeout(self, serviceID, requestID)

    def __init__(self):

            # check for > 2 parents
        gravityParents = set(["GravitySubscriber", "GravityServiceProvider",
                              "GravityRequestor",  "GravityHeartbeatListener"])
        numExtended = len(gravityParents.intersection([c.__name__ for c in self.__class__.__bases__]))
        if numExtended > 2:
            raise ValueError("\n\nCurrently only extending 2 Gravity classes is supported, but extending {}: \n\t\t{}.\nSee https://github.com/aphysci/gravity/issues/190.\n\n".format(numExtended, self.__class__.__bases__))


        if self.__class__ == GravityRequestor:
            _self = None
        else:
            _self = self
        _gravity.GravityRequestor_swiginit(self, _gravity.new_GravityRequestor(_self, ))
    def __disown__(self):
        self.this.disown()
        _gravity.disown_GravityRequestor(self)
        return weakref.proxy(self)

# Register GravityRequestor in _gravity:
_gravity.GravityRequestor_swigregister(GravityRequestor)
class GravityServiceProvider(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _gravity.delete_GravityServiceProvider


            # DO NOT override or alter this method. It is here to convert between a serialized, binary Python string 
            # representing a GravityDataProduct to a GravityDataProduct Python object.
    def requestBinary(self, *args):
        serviceID = args[0]
        try:
            request = GravityDataProduct(data=args[1])
            try:
                response = self.request(serviceID, request)
            except Exception as e:
                logging.exception("Exception caught calling client request")
        except Exception as e:
            logging.exception("Error creating GDP from byte array")
        return response.serializeToString()



    	    # The above request will be renamed as requestBinary, and will be invoked from C++ when a service request is made.
    	    # Python GravityServiceProvider child classes should only override this abstract method.
    @abc.abstractmethod
    def request(self, serviceID, dataProduct): pass


    def __init__(self):

            # check for > 2 parents
        gravityParents = set(["GravitySubscriber", "GravityServiceProvider",
                              "GravityRequestor",  "GravityHeartbeatListener"])
        numExtended = len(gravityParents.intersection([c.__name__ for c in self.__class__.__bases__]))
        if numExtended > 2:
            raise ValueError("\n\nCurrently only extending 2 Gravity classes is supported, but extending {}: \n\t\t{}.\nSee https://github.com/aphysci/gravity/issues/190.\n\n".format(numExtended, self.__class__.__bases__))


        if self.__class__ == GravityServiceProvider:
            _self = None
        else:
            _self = self
        _gravity.GravityServiceProvider_swiginit(self, _gravity.new_GravityServiceProvider(_self, ))
    def __disown__(self):
        self.this.disown()
        _gravity.disown_GravityServiceProvider(self)
        return weakref.proxy(self)

# Register GravityServiceProvider in _gravity:
_gravity.GravityServiceProvider_swigregister(GravityServiceProvider)

